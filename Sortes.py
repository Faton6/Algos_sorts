"""Модуль с реализованными сортировками:
Сортировка простыми вставками, шейкер, слиянием
Сортировка выбором, шейкер, быстрая
"""


def selection_sort(arr):
    """
    Сортировка выбором
    Алгоритм сортировки:
    1. Найти наименьшее значение в списке.
    2. Записать его в начало списка, а первый элемент - на место, где раньше стоял наименьший.
    3. Снова найти наименьший элемент в списке. При этом в поиске не участвует первый элемент.
    4. Второй минимум поместить на второе место списка. Второй элемент при этом перемещается на освободившееся место.
    5. Продолжать выполнять поиcк и обмен, пока не будет достигнут конец списка.

    Средняя сложность O(n ^ 2)
    """
    for i in range(len(arr) - 1):
        m = i
        j = i + 1
        while j < len(arr):
            if arr[j] < arr[m]:
                m = j
            j += 1
        arr[i], arr[m] = arr[m], arr[i]


def shaker_sort(arr):
    """ Шейкер сортировка
    Коктейльная сортировка — разновидность пузырьковой сортировки. Алгоритм пузырьковой сортировки всегда обходит
    элементы слева и перемещает самый большой элемент в правильное положение на первой итерации,
    второй по величине — на второй и так далее. Коктейльная сортировка попеременно проходит через заданный массив
    в обоих направлениях. Коктейльная сортировка не требует ненужных итераций,
    что делает ее эффективной для больших массивов.
    Этапы сортировки:
    1. Массив перебирается слева направо, как и при пузырьковой сортировке.
    Во время цикла сравниваются соседние элементы, и если значение слева больше значения справа,
    значения меняются местами. В конце первой итерации наибольшее число будет находиться в конце массива.
    2. Проход по массиву в обратном направлении — начиная с элемента,
    непосредственно предшествующего последнему отсортированному элементу, и возвращаясь к началу массива.
    Здесь также сравниваются соседние элементы и при необходимости меняются местами.

    Средняя сложность O(n ^ 2)
    """
    for i in range(len(arr) - 1, 0, -1):
        is_swapped = False

        for j in range(i, 0, -1):
            if arr[j] < arr[j - 1]:
                arr[j], arr[j - 1] = arr[j - 1], arr[j]
                is_swapped = True
        for j in range(i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                is_swapped = True

        if not is_swapped:
            return arr


def quick_sort(arr):
    """
    Быстрая сортировка
    Выбрать опорный элемент из массива - обычно первый или средний элемент.
    Разделить массив на два подмассива: элементы меньше опорного и элементы больше опорного.
    Рекурсивно применить сортировку к двум подмассивам.

    Средняя сложность O(n * log2n)
    """
    if len(arr) < 2:
        return arr
    else:
        pivots = [x for x in arr if x == arr[0]]  # Выбираю опорный элемент (первый элемент массива)
        left = [i for i in arr[1:] if i < arr[0]]  # Рекурсивно прохожу по всем подмассивам
        right = [i for i in arr[1:] if i > arr[0]]  # Рекурсивно прохожу по всем подмассивам
        return quick_sort(left) + pivots + quick_sort(right)  # Возвращаю список

